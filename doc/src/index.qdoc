/****************************************************************************
**
** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** GNU Free Documentation License
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file.
**
** Other Usage
** Alternatively, this file may be used in accordance with the terms
** and conditions contained in a signed written agreement between you
** and Nokia.
**
**
**
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
\title Qt JsonDb Reference
\page index.html

\section1 Introduction

\section1 Accessing the Database.

\section2 C++ API

\generatelist annotatedclasses

\section2 QML Elements

\generatelist qmlclasses

\section1 Using the Database

\section2 Schemas

\section2 Query Language

Central to the use of a large object store is the ability to query efficiently
for objects from within the object store. The JsonDB query language was
originally modeled off of the JSON Query language, see
\l {http://docs.persvr.org/documentation/jsonquery}. It has subsequently been
updated for faster performance and features have been added that make it more
suitable for our application.

A simple query consists of square brackets surrounding an expression
(e.g., [EXPR]). A complex query is a string of simple queries concatenated
together (e.g., [EXPR1][EXPR2][EXPR3]). Each expression filters or applies an
action.

\section3 Valid Expressions

\table
\header
\li Expression
\li Description
\row
\li \c {[? filter]}
\li Query for matching objects.
\row
\li \c {[= fields]}
\li Restrict returned objects to particular fields.
\row
\li \c {[/ field]}
\li Sort in ascending order by field.
\row
\li \c {[\ field]}
\li Sort in descending order by field.
\row
\li \c {[count]}
\li Aggregation operation.
\row
\li \c {[*]}
\li Match all objects.
\endtable

See also \l {Expression Examples}

\section3 Stability of Sort in JsonDb

The database as a set of objects with no natural ordering. Any time that we need
objects in a particular order, we use an index that orders the objects by a
particular field and comparison operator. It is unlikely that the sorting in one
index would be stable with respect to all other indexes on that object.

\section2 Indexes

See \l {Object Indexes}

\section3 Query optimization

In general, sorting should only be done on properties for which JSON DB has an
index. Any query with a sort order given for which there is no index, will
result in an error. For a query without explicitly provided sort order, full
object scan is performed, which should be avoided for all but the smallest data
sets.

\section2 Views

\list
\li \l {Map and Join Views}
\endlist

\section2 Notifications

Notifications are created, updated, and removed by using a
\l{QJsonDbConnection::addWatcher()}{dedicated api} which
takes a query expression and a list of actions as an argument. There are
actions available that allow watching for objects being created, updated or
removed from a database.

When a notification matches an action performed on the database, the
QJsonDbWatcher::notificationsAvailable() signal is emitted.

See also \l{QJsonDbWatcher}

\section1 Examples

\list
\li \l{declarative/simplelistmodel}{Simple List Model}
\li \l{declarative/streamingquery}{Streaming Query}
\li \l{declarative/simpleindex}{Simple Object Indexing}
\li \l{declarative/desktop-inspector}{Desktop Database Inspector Example}
\li \l{declarative/map-phone}{Creating a Map View}
\li \l{declarative/joinview}{Creating a Join View}
\endlist
*/
